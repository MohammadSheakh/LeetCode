/**
 *
  Big O notation helps us understand how long an
  algorithm will take to run or how much memory it will
  need as the amount of data it handles grows.
 * @NEW_TOPIC <-- O(n) -->
  |--> the execution time of the algorithm grows linearly
  | in proportion to the size of the input data.
 
 
 * @INFO 
  | n+n = 2n -> O(n) // Drop the constant so it becomes O(n)
 
 
  * @NEW_TOPIC <-- O(1) -->
  |--> O(1) aka constant time ..
  | the execution time of an algo remains constant regardless of the 
  | input size 
  +---------- 
  | Ex : accessing an element in an array by index.. 


  * @NEW_TOPIC <-- O(n^2) -->
  |--> indicatess that the algo's execution time grows quadratically
  | with the size of the input data.
  +-----------
  | Ex : nested loops iterating over the same array. Bubble sort, selection sort  
 

  * @New_Topic <-- O(log n) -->
  |--> indicates that the algorithm's execution time grows logarithmically
  | .. as the input size increases, the time it takes for the also to run 
  | increases slowly  ... operation are typically halved at each step . 
  +-----------
  | Ex : binary search in a sorted array. 


  * @New_Topic <-- O(n log n) -->
  |--> Linearithmic .. time taken increases in a linearithmic manner, often seen in 
  | divide and conquer algorithms 
  +----------- 
  | Ex : Merge sort, quick sort

 */

/**
  * @NEW_TOPIC <!--    -->
  |
  |-->
  |
  +----------- 
  | Ex :
 


  * @INFO <!--    -->
  |
  |-->
  |
 */
